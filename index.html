<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grand Luxury Interactive Christmas Tree</title>
  <!-- 正确排序CDN，先依赖后上层库，避免未定义 -->
  <script src="https://unpkg.com/three@0.182.0/build/three.min.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@react-three/fiber@9.4.2/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@react-three/drei@10.7.7/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@react-three/postprocessing@3.0.4/dist/umd/index.min.js"></script>
  <!-- 字体引入 -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Lato:wght@300;400&display=swap" rel="stylesheet">
  <!-- 完全移除Tailwind CDN，用纯CSS替代所有样式 -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background-color: #001a0f;
      overflow: hidden;
      font-family: 'Lato', sans-serif;
    }
    #root {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* 切换按钮样式（替代Tailwind） */
    .toggle-button {
      padding: 12px 24px;
      background-color: #15803d;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-family: 'Playfair Display', serif;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .toggle-button:hover {
      background-color: #16a34a;
    }
    .toggle-button:active {
      background-color: #1e40af;
    }
    /* 加载失败提示样式 */
    .error-tip {
      color: #fff;
      text-align: center;
      font-size: 18px;
      padding: 20px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    // 等待所有CDN加载完成再执行，避免未定义
    window.addEventListener('load', function() {
      // 解构API并增加容错
      const ReactLib = window.React;
      const ReactDOMLib = window.ReactDOM;
      const THREE = window.THREE || {};
      const R3F = window.ReactThreeFiber || {};
      const R3Drei = window.ReactThreeDrei || {};
      const R3Post = window.ReactThreePostprocessing || {};

      if (!ReactLib || !ReactDOMLib || !R3F.Canvas) {
        const root = document.getElementById('root');
        root.innerHTML = '<div class="error-tip">3D组件加载失败，请刷新页面重试</div>';
        return;
      }

      const { useState, useRef, Fragment, StrictMode } = ReactLib;
      const { Canvas, useFrame } = R3F;
      const { OrbitControls, Environment, Stars, Sparkles, Html } = R3Drei;
      const { EffectComposer, Bloom, Vignette, Noise } = R3Post;

      // 常量配置
      const COLORS = {
        emerald: "#008000",
        champagne: "#F7E7CE",
        gold: "#FFD700"
      };
      const CONFIG = {
        treeHeight: 8,
        particleCount: 5000
      };

      // 树形状态
      const TreeState = {
        FORMED: "formed",
        CHAOS: "chaos"
      };

      // 兔子组件（纯React.createElement，无JSX）
      const Rabbit = ({ scale }) => {
        return ReactLib.createElement(
          "group",
          { scale: scale || 1 },
          ReactLib.createElement(
            "mesh",
            { position: [0, 0, 0] },
            ReactLib.createElement("sphereGeometry", { args: [0.5, 32, 32] }),
            ReactLib.createElement("meshStandardMaterial", { color: "#ffffff" })
          ),
          ReactLib.createElement(
            "mesh",
            { position: [0.3, 0.3, 0.2] },
            ReactLib.createElement("sphereGeometry", { args: [0.1, 16, 16] }),
            ReactLib.createElement("meshStandardMaterial", { color: "#000000" })
          ),
          ReactLib.createElement(
            "mesh",
            { position: [-0.3, 0.3, 0.2] },
            ReactLib.createElement("sphereGeometry", { args: [0.1, 16, 16] }),
            ReactLib.createElement("meshStandardMaterial", { color: "#000000" })
          )
        );
      };

      // 树粒子组件
      const TreeParticles = ({ state }) => {
        const ref = useRef();
        const particlesRef = useRef();

        if (useFrame) {
          useFrame(({ clock }) => {
            if (!ref.current || !particlesRef.current) return;

            const time = clock.elapsedTime;
            if (state === TreeState.FORMED) {
              particlesRef.current.rotation.y += 0.005;
            } else {
              particlesRef.current.rotation.x = Math.sin(time * 0.5) * 0.2;
              particlesRef.current.rotation.z = Math.cos(time * 0.5) * 0.2;
            }
          });
        }

        return ReactLib.createElement(
          "group",
          { ref: ref },
          ReactLib.createElement(
            "points",
            { ref: particlesRef },
            ReactLib.createElement(
              "bufferGeometry",
              null,
              ReactLib.createElement("bufferAttribute", {
                count: CONFIG.particleCount,
                array: new Float32Array(CONFIG.particleCount * 3),
                itemSize: 3
              })
            ),
            ReactLib.createElement("pointsMaterial", {
              color: COLORS.emerald,
              size: 0.05,
              transparent: true,
              opacity: 0.8,
              sizeAttenuation: true
            })
          )
        );
      };

      // 树顶组件
      const TreeTopper = ({ state }) => {
        const groupRef = useRef(null);
        const targetY = CONFIG.treeHeight / 2 + 0.2;

        if (useFrame && THREE.MathUtils && THREE.Vector3) {
          useFrame((stateThree, delta) => {
            if (!groupRef.current || !stateThree.clock) return;

            const target = state === TreeState.FORMED
              ? new THREE.Vector3(0, targetY, 0)
              : new THREE.Vector3(
                  Math.sin(stateThree.clock.elapsedTime) * 5,
                  5 + Math.cos(stateThree.clock.elapsedTime * 0.5) * 2,
                  Math.cos(stateThree.clock.elapsedTime) * 5
                );

            if (groupRef.current.position.lerp) {
              groupRef.current.position.lerp(target, delta * 2);
            }

            if (state === TreeState.FORMED) {
              groupRef.current.rotation.y += delta * 0.5;
              groupRef.current.rotation.z = THREE.MathUtils.lerp(groupRef.current.rotation.z, 0, delta);
              groupRef.current.rotation.x = THREE.MathUtils.lerp(groupRef.current.rotation.x, 0, delta);
            } else {
              groupRef.current.rotation.x += delta;
              groupRef.current.rotation.z += delta;
            }
          });
        }

        return ReactLib.createElement(
          "group",
          { ref: groupRef },
          ReactLib.createElement(Rabbit, { scale: 0.8 })
        );
      };

      // 核心体验组件（修复OrbitControls属性写法，纯原生JS）
      const Experience = () => {
        const [treeState, setTreeState] = useState(TreeState.FORMED);

        const onToggle = () => {
          setTreeState(prev => prev === TreeState.FORMED ? TreeState.CHAOS : TreeState.FORMED);
        };

        // 构建OrbitControls属性（原生JS对象，避免JSX语法错误）
        const orbitControlsProps = {
          enablePan: false,
          enableZoom: true,
          minPolarAngle: Math.PI / 4,
          maxPolarAngle: Math.PI / 1.8,
          minDistance: 6,
          maxDistance: 20
        };

        return ReactLib.createElement(
          Fragment,
          null,
          ReactLib.createElement(
            Canvas,
            {
              shadows: true,
              dpr: [1, 2],
              camera: { position: [0, 0, 12], fov: 45 },
              gl: { toneMapping: THREE.ReinhardToneMapping || 0, toneMappingExposure: 1.5 }
            },
            ReactLib.createElement("color", { attach: "background", args: ['#001a0f'] }),
            // OrbitControls：传入纯JS对象属性，修复语法错误
            OrbitControls ? ReactLib.createElement(OrbitControls, orbitControlsProps) : null,
            // 环境与灯光
            Environment ? ReactLib.createElement(Environment, { preset: "city" }) : null,
            ReactLib.createElement("ambientLight", { intensity: 0.2, color: COLORS.emerald }),
            ReactLib.createElement("spotLight", {
              position: [10, 10, 10],
              angle: 0.15,
              penumbra: 1,
              intensity: 2,
              castShadow: true,
              color: COLORS.champagne
            }),
            ReactLib.createElement("pointLight", { position: [-10, -5, -10], intensity: 5, color: COLORS.emerald }),
            ReactLib.createElement("pointLight", { position: [0, 5, 5], intensity: 2, color: COLORS.gold, distance: 10 }),
            // 背景元素
            Stars ? ReactLib.createElement(Stars, { radius: 100, depth: 50, count: 5000, factor: 4, saturation: 0, fade: true, speed: 1 }) : null,
            // 圣诞树
            ReactLib.createElement(
              "group",
              { position: [0, -1, 0] },
              ReactLib.createElement(TreeParticles, { state: treeState }),
              ReactLib.createElement(TreeTopper, { state: treeState })
            ),
            // 特效
            Sparkles ? ReactLib.createElement(Sparkles, {
              count: 200,
              scale: 12,
              size: 4,
              speed: 0.4,
              opacity: 0.5,
              color: COLORS.gold
            }) : null,
            // 地面反射
            ReactLib.createElement(
              "mesh",
              { rotation: [-Math.PI / 2, 0, 0], position: [0, -4, 0] },
              ReactLib.createElement("planeGeometry", { args: [100, 100] }),
              ReactLib.createElement("meshStandardMaterial", {
                color: "#001a0f",
                roughness: 0,
                metalness: 0.5,
                transparent: true,
                opacity: 0.8
              })
            ),
            // 后期处理
            EffectComposer ? ReactLib.createElement(
              EffectComposer,
              { disableNormalPass: true },
              ReactLib.createElement(Bloom, {
                luminanceThreshold: 0.8,
                mipmapBlur: true,
                intensity: 1.2,
                radius: 0.6
              }),
              ReactLib.createElement(Vignette, { eskil: false, offset: 0.1, darkness: 1.1 }),
              ReactLib.createElement(Noise, { opacity: 0.02 })
            ) : null
          ),
          // 切换按钮
          Html ? ReactLib.createElement(Html, { position: [0, -3, 0], transform: true },
            ReactLib.createElement("button", {
              onClick: onToggle,
              className: "toggle-button"
            },
            treeState === TreeState.FORMED ? "切换为混乱状态" : "切换为树形状态"
            )
          ) : ReactLib.createElement("button", {
            onClick: onToggle,
            className: "toggle-button",
            style: { position: "absolute", top: "55%", left: "50%", transform: "translate(-50%, 0)" }
          },
            treeState === TreeState.FORMED ? "切换为混乱状态" : "切换为树形状态"
          )
        );
      };

      // 渲染组件
      const rootElement = document.getElementById('root');
      const root = ReactDOMLib.createRoot(rootElement);
      root.render(
        ReactLib.createElement(StrictMode, null,
          ReactLib.createElement(Experience, null)
        )
      );
    });
  </script>
</body>
</html>
